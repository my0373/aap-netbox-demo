- name: Process NetBox device webhook (main branch only)
  hosts: localhost
  gather_facts: false

  vars:
    # Recommended: inject these via an AAP Credential (env vars)
    netbox_url: "{{ lookup('env', 'NETBOX_URL') | default('', true) }}"
    netbox_token: "{{ lookup('env', 'NETBOX_TOKEN') | default('', true) }}"

  tasks:
    # --- Optional debug (kept safe; skips if not present) ---
    - name: Show extra_vars if present (AAP often injects NetBox webhook extra_vars here)
      ansible.builtin.debug:
        var: extra_vars
      when: extra_vars is defined

    - name: Show awx_webhook_payload if present
      ansible.builtin.debug:
        var: awx_webhook_payload
      when: awx_webhook_payload is defined

    - name: Show tower_webhook_payload if present (legacy Tower)
      ansible.builtin.debug:
        var: tower_webhook_payload
      when: tower_webhook_payload is defined

    # --- Map webhook vars (supports your NetBox template: { "extra_vars": { ... } }) ---
    - name: Map NetBox webhook payload to vars (AAP/AWX/Tower) - supports extra_vars template
      ansible.builtin.set_fact:
        device_data: >-
          {{
            (extra_vars.device_data
              | default(awx_webhook_payload.extra_vars.device_data, true)
              | default(tower_webhook_payload.extra_vars.device_data, true)
              | default(awx_webhook_payload.data, true)
              | default(tower_webhook_payload.data, true)
              | default({}, true))
          }}
        event_meta: >-
          {{
            (extra_vars.event_meta
              | default(awx_webhook_payload.extra_vars.event_meta, true)
              | default(tower_webhook_payload.extra_vars.event_meta, true)
              | default({
                  'event_type': (awx_webhook_payload.event | default(tower_webhook_payload.event, true) | default('')),
                  'model': (awx_webhook_payload.model | default(tower_webhook_payload.model, true) | default('')),
                  'username': (awx_webhook_payload.username | default(tower_webhook_payload.username, true) | default('')),
                  'request_id': (awx_webhook_payload.request_id | default(tower_webhook_payload.request_id, true) | default(''))
                }, true))
          }}
        branch_gate: >-
          {{
            (extra_vars.branch_gate
              | default(awx_webhook_payload.extra_vars.branch_gate, true)
              | default(tower_webhook_payload.extra_vars.branch_gate, true)
              | default({}, true))
          }}

    - name: Assert webhook vars are present
      ansible.builtin.assert:
        that:
          - device_data is mapping
          - device_data.id is defined
        fail_msg: >-
          device_data.id not found. Ensure NetBox webhook body template sends
          extra_vars.device_data.id (and that AAP is receiving it).

    - name: Assert NetBox connection vars are present
      ansible.builtin.assert:
        that:
          - netbox_url | length > 0
          - netbox_token | length > 0
        fail_msg: "Missing NETBOX_URL/NETBOX_TOKEN (inject via AAP Credential or env vars)."

    # --- Main-branch gate: query Branching changes endpoint; skip if object has branch changes ---
    - name: Set branch gate inputs (fallbacks)
      ansible.builtin.set_fact:
        branch_object_id: "{{ branch_gate.object_id | default(device_data.id) }}"
        branch_model: "{{ branch_gate.model | default('dcim.device') }}"

    - name: Query Branching changes endpoint for this object
      ansible.builtin.uri:
        url: >-
          {{ netbox_url | regex_replace('/$', '') }}/api/plugins/branching/changes/
          ?object_id={{ branch_object_id }}&model={{ branch_model }}
        method: GET
        headers:
          Authorization: "Token {{ netbox_token }}"
          Accept: "application/json"
        return_content: true
        status_code: 200
      register: branch_changes
      no_log: true  # prevents headers/token from being printed if verbosity is high

    - name: Decide whether to proceed (main branch only)
      ansible.builtin.set_fact:
        is_main_branch: "{{ (branch_changes.json.results | default([]) | length) == 0 }}"
        effective_branch: >-
          {{
            'main'
            if (branch_changes.json.results | default([]) | length) == 0
            else (branch_changes.json.results[0].branch.name | default('unknown'))
          }}

    - name: Skip if not main
      ansible.builtin.debug:
        msg: >-
          Skipping automation: device {{ device_data.name | default(device_data.id) }}
          has pending branch changes (effective_branch={{ effective_branch }}).
          request_id={{ event_meta.request_id | default('') }}
      when: not is_main_branch

    - name: End play if not main
      ansible.builtin.meta: end_play
      when: not is_main_branch

    # --- From here down: your automation (runs only on main) ---
    - name: Show device data (main only)
      ansible.builtin.debug:
        var: device_data

    - name: Show event metadata (main only)
      ansible.builtin.debug:
        var: event_meta

    - name: Show branch decision (main only)
      ansible.builtin.debug:
        msg:
          branch_object_id: "{{ branch_object_id }}"
          branch_model: "{{ branch_model }}"
          is_main_branch: "{{ is_main_branch }}"
          effective_branch: "{{ effective_branch }}"
